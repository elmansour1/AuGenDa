CompiledMethod variableByteSubclass: #AuGenDa	instanceVariableNames: ''	classVariableNames: ''	package: 'Faouzi'!!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 9/27/2022 18:05'!decomp: method	|var t types classMethod yTypes L|	L := OrderedCollection new.	t := OrderedCollection new.	classMethod := method methodClass.	var := method variableWriteNodes.	(var collect: [ :i | t add:i name]).	types := TypeCollector typeInstvarsOfClass:classMethod.	(t) collect:  [: i | 	yTypes := types at:i.	L add:yTypes types	].^L! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 10/23/2022 12:50'!getClass: aMethod	^ aMethod methodClass.		! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 10/13/2022 19:44'!gen: method	|ok okk|	okk := AuGenDa new.	okk decompose:#'method'.	"okk := okk value."	^okk! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 11/15/2022 13:37'!myMethod: data^String streamContents:    [:stream|        stream        space;cr.      data asArray do: [ :aData| stream << aData asString ]                     separatedBy:  [ stream space ]    ]! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 11/16/2022 19:43'!getVariablesWriteNode: method 	|var variableNamesNode|		variableNamesNode := OrderedCollection new.	var := method variableWriteNodes.	(var collect: [ :i | variableNamesNode add:i value ]).	^ variableNamesNode ! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 10/21/2022 18:40'!getSelectors: aClass	|names selector|		names :=	 aClass allInstVarNames.		selector := aClass selectors.		(selector endsWith: ':')		ifTrue: [ "selector might be a setter" selector := selector allButLast ].	(names includes: selector)		! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 11/16/2022 08:31'!tmpVariables 	^'|classMethod setter instObject|'.! !!AuGenDa methodsFor: 'as yet unclassified' stamp: 'FAOUZIELMANSOUR 10/12/2022 19:08'!generateTestClassFor: aClass	|class|	class := Smalltalk globals allClasses.	^class compile: (self buildTestClassDefinitionFrom:aClass)! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 10/17/2022 11:53'!compose: items	! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 10/17/2022 12:04'!mutate: typ	|items|	items := OrderedCollection new.	typ collect: [ :i | 		(i isFloat ) ifTrue: [ items add: ((1 to: 1000) atRandom asFloat) ].		(i = SmallInteger) ifTrue: [ items add:(1 to: 256) atRandom ]. 		(i isInteger) ifTrue: [ items add:(1 to: 256) atRandom ].		(i isNumber) ifTrue: [ items add:(1 to: 256) atRandom ].		(i isString )		ifTrue: [ items add:UUID new asString36].		(i == ByteString ) ifTrue: [ items add:UUID new asString36].		(i == Date) ifTrue: [ items add:(Date fromDays: (1 to: 36000)atRandom) ].		  ].	^items	! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 10/17/2022 12:10'!compose: items method: aMethod andClass: aClass	|classMethod setter instObject|		classMethod := aMethod methodClass.	setter := Array new.	setter := (self getAllSelectorsInMySetterProtocol: classMethod).	instObject := classMethod new.	(setter with: items do: [:set :ivar | instObject  perform: set with: ivar]).	^instObject ! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 11/15/2022 15:06'!generateData: method	|typ param  classMethod items instObject testMethod classTest t|	param := OrderedCollection new.	param := method argumentNames.	typ := OrderedCollection new.	items := OrderedCollection new.	classMethod := method methodClass.	instObject := method methodClass new.	t := Array new.	typ := (self generateD:method).	items := (self mutate:typ).	instObject := (self compose:items method:method andClass:classMethod).	testMethod := method methodClass name , 'Test'.	classTest := Smalltalk globals allClasses		detect: [ :e | e name = testMethod ]		ifNone: [ self createTestForClass: method methodClass ].		classTest 		compile: (self writeSetup: method with: items )		classified:'tests'.	classTest			compile: (self writeTestMethod: method with:items)			classified: 'tests'.	^instObject   						 ! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 10/17/2022 12:12'!getAllSelectorsInMySetterProtocol: aClass	|selectors|	selectors := selectors := (aClass allSelectorsInProtocol: #setter) asArray.	^selectors ! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 10/17/2022 11:46'!generateD: method	^ self decompose: method.! !!AuGenDa methodsFor: '*Kernel' stamp: 'FAOUZIELMANSOUR 10/13/2022 19:22'!decompose: method	|var t types classMethod yTypes L resultTypes|	L := OrderedCollection new.	t := OrderedCollection new.	resultTypes  := OrderedCollection new.	classMethod := method methodClass.	var := classMethod instVarNames.	(var collect: [ :i | t add:i  ]).	types := TypeCollector typeInstvarsOfClass:classMethod.	(t) collect:  [: i | 	yTypes := types at:i.	L add:yTypes types	].  resultTypes := L collect: [ :each | each first].	^resultTypes ! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:19'!generateCommentForTestClass: testClass from: aClass	^ String streamContents: [:stream || name |			name := testClass name. 			name first isVowel				ifTrue: [ stream << 'An ']				ifFalse:[ stream <<'A '].			stream << name << ' is a test class for testing the behavior of '<< aClass name ]! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:19'!generateSourceCodeForTestFrom: aMethod	^ self buildTestSelectorFor: aMethod.! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:18'!buildTestClassNameFrom: aClass		^ (aClass name asString,'Test') asSymbol! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:17'!buildTestClassDefinitionFrom: aClass	^ TestCase subclass:(self buildTestClassNameFrom: aClass)	instanceVariableNames: ''	classVariableNames: ''	package:(self buildTestPackageNameFrom:aClass)! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:19'!findTestClass: aMethod 	| class testMethodName |	testMethodName := aMethod methodClass name , 'Test'.	^class := Smalltalk globals allClasses		detect: [ :e | e name = testMethodName ].! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/11/2022 23:13'!writeTestMethod: anObject andClass: aClass	|myClass|	myClass := aClass new.	self assert:anObject class equals: myClass class.! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:18'!createTestForClass: aClass	| definition testClass className |	aClass ifNil: [ ^ nil ].	aClass isTestCase		ifTrue: [ ^ nil ].	aClass isMeta		ifTrue: [ ^ nil ].	className := self buildTestClassNameFrom: aClass.	testClass := self class environment		at: className		ifPresent: [ :class | class ]		ifAbsent:			[ 			definition := self buildTestClassDefinitionFrom: aClass.			testClass := TestCase subclass: className								instanceVariableNames: ''								classVariableNames: ''								package: aClass package.			self class environment at: className.			testClass				comment:					(self generateCommentForTestClass: testClass from: aClass) ].	^ testClass! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:18'!buildTestSelectorFor: aMethod	^ String streamContents: [:s || capitalize |		capitalize := true.		s << 'test'.		aMethod selector do: [:c |			c = $:				ifTrue: [ capitalize := true ]				ifFalse: [ capitalize							ifTrue: [ 								capitalize := false.								s << c asUppercase. ]							ifFalse:[ s << c ]]]]! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:19'!generateTestMethodFor: aMethod	"generate a test method for aMethod and return the generated method"	| class testMethodName |	testMethodName := aMethod methodClass name , 'Test'.	class := Smalltalk globals allClasses		detect: [ :e | e name = testMethodName ]		ifNone: [ self createTestForClass: aMethod methodClass ].	class		ifNotNil: [ class				compile: (self generateSourceCodeForTestFrom: aMethod)				classified: 'tests-' , aMethod category.			^ class >> (self buildTestSelectorFor: aMethod) asSymbol ].	^ nil! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 11/15/2022 13:38'!writeSetup: aMethode with:anObject	|setter variableNameNodes person c fdt t|	variableNameNodes := self getVariablesWriteNode: aMethode.	setter :=	(aMethode methodClass allSelectorsInProtocol: #setter) asArray .		person := aMethode methodClass new.		(setter with: anObject  do: [:set :ivar | person perform: set with: ivar]).		c := ((setter at:1) separateKeywords).		fdt := (setter at:1) findTokens: $#.	^String streamContents:		[ :stream| 		stream	 	nextPutAll: 'setUp';		cr;tab;	 	nextPutAll: 'super setUp.';		cr;tab;		nextPutAll: 'data := ';		print: aMethode methodClass;		nextPutAll: ' new ';		print: person.]! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 10/19/2022 21:18'!buildTestPackageNameFrom:aClass	^ aClass package name asString, '-Tests'! !!AuGenDa methodsFor: 'writing' stamp: 'FAOUZIELMANSOUR 11/16/2022 20:20'!writeTestMethod: aMethod with: anObject 	| method object instObject setter getter variablesName|	setter :=	(aMethod methodClass allSelectorsInProtocol: #setter) asArray .		getter :=	(aMethod methodClass allSelectorsInProtocol: #getter) asArray.	variablesName := (self getVariablesWriteNode: aMethod).	instObject := aMethod methodClass new.	(setter with: anObject do: [:set :ivar | instObject  perform: set with: ivar]).	^object := String streamContents:		[ :stream| 		stream	 	nextPutAll: (self buildTestSelectorFor: aMethod);		cr;tab;		nextPutAll:'self assert: data ';		nextPutAll: ((getter at:1)) asString;		nextPutAll:'  equals: ';		print: (anObject at:1);		nextPutAll:'.'.		]! !